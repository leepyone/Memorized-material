### [1、c++ 多态](https://blog.csdn.net/qq_53558968/article/details/116886784)

C++的多态必须满足两个条件：
1 必须通过基类的指针或者引用调用虚函数
2 被调用的函数是虚函数，且必须完成对基类虚函数的**重写**

**虚函数**：
用virtual修饰的关键字就是虚函数。
虚函数只能是类中非静态的成员函数。

**虚函数表**：
- 虚函数表是一个虚函数指针数组，最后一个元素是nullptr，代表虚表的结束。
- 继承问题：
  1. 子类先拷贝一份父类虚表，然后用一个虚表指针指向这个虚表。
  2. 如果有虚函数重写，那么在子类的虚表上用子类的虚函数覆盖。
  3. 子类新增的虚函数按其在子类中的声明次序增加到子类虚表的最后。
  4. 多继承的话，会继承所有父类的虚函数表

**协变**：
子类的虚函数和父类的虚函数的**返回值**可以不同，也能构成重载。但需要子类的返回值是一个**子类的指针**或者引用，父类的返回值是一个**父类的指针**或者引用，且返回值代表的两个类也成**继承关系**。这个叫做协变。

**概念区分**
重载：同一个类中相同名函数的，参数列表不必相同
重写：重写父类中的函数，必须是虚函数才能重写。
重定义:
    - 如果派生类的函数和基类的函数同名，但是**参数不同**，此时，不管有无virtual，基类的函数被隐藏。
    - 如果派生类的函数与基类的函数同名，并且**参数也相同**，但是基类函数没有vitual关键字，此时，基类的函数被隐藏。否则就是重写了。

抽象类：
存在纯虚函数的类：接口类
纯虚函数：虚函数 + =0

```c++
class Car
{
 public:
    virtual void fun() = 0; //不用实现，只写接口就行。
}

```

**多态的原理**：
满足多态的函数调用是程序运行是去**对象的虚表**查找的，而**虚表是在编译时确定**的
普通函数的调用是编译时就确定的

### 2、内联函数
1. 定义：如果一个函数是内联的，那么在编译时，编译器会把该函数的**代码副本**放置在每个**调用该函数**的地方。
2. 目的：解决函数调用的额外开销，压栈、弹栈、复原现场带来的开销
3. 优点：减少函数频繁调用带来的开销，
4. 缺点：增加了代码程序的体积
5. 和宏定义的区别：宏由预处理器在预处理阶段展开,内联函数是由编译器控制的。在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。内联函数是函数,可以进行诸如类型安全检查、语句是否正确等编译功能。宏不是函数,不具有这样的功能。